{"title":"3 — Group and code responses","markdown":{"yaml":{"title":"3 — Group and code responses","date":"2024-01-03","date-modified":"last-modified","image":"sort_elmo.png","format":{"html":{"toc":true,"toc-depth":3,"warning":false,"message":false}},"categories":["code","group","themes"]},"headingText":"Crayon colors","containsRefs":false,"markdown":"\n\n\n\n<img src=\"crayons.jpg\" style=\"margin-right: 16px; margin-bottom: 2px; margin-left: -20px;\" align=\"left\" width=\"184\" alt=\"A box of 12 Crayola crayons.\" >\n\nLet's start simple and assign crayons a color based on their descriptive names. Below is a table of 12 crayons and their names. We want to create a group for each of the primary colors - `red`, `yellow`, and `blue` - and an everything-else group labeled `other`. \n\nWe'll begin by searching for the primary color words in the name column of each of the crayons. If a color word is *detected*, it will be assigned to the appropriate group. \n\n\n### Load the data\n```{r}\nlibrary(tidyverse)\n\ncrayons <- read_csv('https://tidy-mn.github.io/qualitative-guide/posts/data/crayons.csv') \n\ncrayons\n```\n\n\n### Find color words\n\nWe'll use `case_when()` and `str_detect()` to test if a crayon name contains a given primary color word. If it does, we'll assign the crayon to that color. If none of the primary color words are detected, the crayon will be assigned to the group `other`.\n\n```{r}\ncrayons_groups <- crayons %>%\n                  mutate(group = case_when(str_detect(name, \"red\") ~ \"RED\",\n                                           str_detect(name, \"yellow\") ~ \"YELLOW\",\n                                           str_detect(name, \"blue\") ~ \"BLUE\",\n                                           .default = \"other\"))\n\ncrayons_groups %>% head(5)\n```\n\n\n### Fuzzy join\n\nThe approach above works well for a small number of groups but it can become cumbersome when you have lots of groups to assign. If we wanted to sort the crayons into many more color groups, a better approach would be to create a table to store our group names and the color word associated with it. Then we can use `fuzzyjoin` to join the groups table to the crayons table. The end result is the same, but it requires less code and will be much easier to update when we want to add new groups or change the words associated with a group.\n\nHere's the same example as above using the new table approach.\n\n\n### Create the group table\n\nFirst, create a table of our groups with two columns:\n\n- `group` The group name\n- `word` The word associated with the group\n\n```{r}\nlibrary(tidyverse)\nlibrary(fuzzyjoin)\n\ncolor_groups <- tibble(group = c('RED','YELLOW','BLUE'), \n                       word = c(\"red\", \"yellow\", \"blue\")) \n```\n\n\n### Join groups with fuzzy_left_join\n\nNow we can join our two tables using the `name` column in the *crayons* table, and the `word` column in the *color_groups* table. The function used to match the crayon name to its group is `str_detect`, which tests whether a given word occurs anywhere in the crayon's name. \n\n```{r}\ncrayons_groups <- crayons %>%\n                  fuzzy_left_join(color_groups, \n                                  by = join_by(name == word), \n                                  match_fun = str_detect)\n\ncrayons_groups %>% head()\n```\n\n\n### Set the `NA`'s group to \"other\"\n\nFinally, we'll use `replace_na()` to assign all of the crayons without a color group to the group \"other\".\n\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  replace_na(list(group = \"other\"))\n\ncrayons_groups %>%\n  select(id, name, group) %>%\n  head(10)\n```\n\n\n> Now that's interesting. Why do you think the **incredible pink** crayon was assigned to the group `RED`?\n\n\n### Finding complete words\n\nIn the example above, the function `str_detect()` looked for the occurrence of the designated letters anywhere in the crayon name. So the pattern of letters \"r-e-d\" is detected even if it occurs within another word. In this case, the pattern occurs within the name \"inc**red**ible pink\". That could be useful in some contexts, but in our current crayon situation, we only want to detect the word \"red\". \n\nTo ensure the color \"red\" is only detected as a complete word, we can add a special character to the start and end of our search term. Adding the character `\\\\b` to both sides of \"red\" will require the letters \"r-e-d\" to occur as its own word and not as part of a longer word.\n\nFinally, let's paste `\\\\b` to both sides of the color words in the *color_groups* table and then try our fuzzyjoin one more time.\n\n```{r}\ncolor_groups <- color_groups %>%\n                mutate(word = paste0(\"\\\\b\", word, \"\\\\b\"))\n\n# Join the groups again, but with the added separate word requirement\ncrayons_groups <- crayons %>%\n                  fuzzy_left_join(color_groups, \n                                  by = join_by(name == word), \n                                  match_fun = str_detect)\n\ncrayons_groups %>%\n  select(id, name, group) %>%\n  head(10)\n```\n\n\n> Success!\n\n\n### The **\"other\"** group\n\nWe can lump the remaining crayons that were not labeled with a primary color into an *other* group. The `replace_na()` function is used to replace all of the `NA` values in a given column. Let's use it to set the group for the `NA` crayons to \"other\".\n\n\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  replace_na(list(group = \"other\"))\n\ncrayons_groups %>%\n  select(id, name, group) %>%\n  head(10)\n```\n\n## Assign umbrella groups: Parent and child nodes\n\nWe want to sort our crayons into primary colors and secondary colors. To do this we'll need to check a crayon name for multiple words. For example, a crayon will be assigned to the primary color group if any of the following words occur in its name: `red`, `yellow`, or `blue`.\n\nThe larger umbrella group is sometimes referred to as the *parent node*, and the individual terms that fall under it are its *children nodes*. Here's the table of our color groups in terms of parent and child nodes.\n\n```{r}\ncolor_group_nodes <- tribble(\n  ~parent, ~child,\n  \"primary\",   \"red\",\n  \"primary\",   \"yellow\",\n  \"primary\",   \"blue\",\n  \"secondary\", \"green\",\n  \"secondary\", \"orange\",\n  \"secondary\", \"purple\",\n)\n```\n\n\n## Fuzzy join primary and secondary\n\nNow we can repeat our previous fuzzy join steps to assign each of the crayons to `primary`, `secondary`, or `other`.\n\n```{r}\ncolor_group_nodes <- color_group_nodes %>%\n                     mutate(child_word = paste0(\"\\\\b\", child, \"\\\\b\"))\n\n# Join the primary/secondary groups\ncrayons_groups <- crayons %>%\n                  fuzzy_left_join(color_group_nodes, \n                                  by = join_by(name == child_word), \n                                  match_fun = str_detect) %>%\n                  replace_na(list(parent = \"other\"))\n\ncrayons_groups %>%\n  select(id, name, parent, child) %>%\n  head(10)\n```\n\n\n\n## Assign multiple tags\n\nWhen we work with longer pieces of text we may want to assign it multiple groups or tags. For example, the description of a kids' TV show may be about both `dinosaurs` and `siblings`. \n\nIn this example we will label the shows about people and tag each description with the type of people it references, such as `sister`, `brother`, or `grandmother`.\n\n### Load kids TV data\n```{r}\n#| echo: false\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(fuzzyjoin)\n```\n\n```{r}\n#| cache: true\n\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(fuzzyjoin)\n\ntv_shows <- read_csv('https://tidy-mn.github.io/qualitative-guide/posts/data/kids_netflix_shows.csv')\n```\n\n\n### Split up / `unnest` every word for easy group joining\n```{r}\ntv_shows <- tv_shows %>%\n            unnest_tokens(word, description, drop = FALSE)\n```\n\n\n### Load the parent and child node table\n\nHere we provide an example parent/child node table to tag descriptions with various types of people. We include both the singular and plural version of a term - such as *uncle* and *uncles*. \n\n```{r}\ntv_nodes <- read_csv(\"https://tidy-mn.github.io/qualitative-guide/posts/data/people_nodes.csv\")\n\ntv_nodes %>% head()\n```\n\n\n\n### Join the parent/child `nodes` table to the `tv_shows`\n\n```{r}\ntv_groups <- tv_shows %>%\n             left_join(tv_nodes, \n                       by = join_by(word == child_words))\n\n# Drop the rows/words with no word matches\ntv_groups <- tv_groups %>%\n             filter(!is.na(parent))\n\n# View word matches\ntv_groups %>%\n  select(title, description, parent, child) %>%\n  arrange(child) %>%\n  head() %>%\n  knitr::kable()\n```\n\n\n## Summarize\n\nTo simplify things, let's take all of the assigned parent and child tags for each movie and bring them together into a comma separated list.\n```{r}\ntv_groups <- tv_groups %>%\n              filter(!is.na(parent)) %>%\n              group_by(show_id, type, title, country, release_year, description) %>%\n              summarize(parent_nodes = paste(parent %>% unique %>% sort, collapse = \", \"),\n                        child_nodes = paste(child %>% unique %>% sort, collapse = \", \"),\n                        .groups = \"drop\")\n  \n# View r\ntv_groups %>%\n  select(title, description, parent_nodes, child_nodes) %>%\n  arrange(-nchar(child_nodes)) %>%\n  head(12) %>%\n  knitr::kable()\n```  \n\n","srcMarkdownNoYaml":"\n\n\n## Crayon colors\n\n<img src=\"crayons.jpg\" style=\"margin-right: 16px; margin-bottom: 2px; margin-left: -20px;\" align=\"left\" width=\"184\" alt=\"A box of 12 Crayola crayons.\" >\n\nLet's start simple and assign crayons a color based on their descriptive names. Below is a table of 12 crayons and their names. We want to create a group for each of the primary colors - `red`, `yellow`, and `blue` - and an everything-else group labeled `other`. \n\nWe'll begin by searching for the primary color words in the name column of each of the crayons. If a color word is *detected*, it will be assigned to the appropriate group. \n\n\n### Load the data\n```{r}\nlibrary(tidyverse)\n\ncrayons <- read_csv('https://tidy-mn.github.io/qualitative-guide/posts/data/crayons.csv') \n\ncrayons\n```\n\n\n### Find color words\n\nWe'll use `case_when()` and `str_detect()` to test if a crayon name contains a given primary color word. If it does, we'll assign the crayon to that color. If none of the primary color words are detected, the crayon will be assigned to the group `other`.\n\n```{r}\ncrayons_groups <- crayons %>%\n                  mutate(group = case_when(str_detect(name, \"red\") ~ \"RED\",\n                                           str_detect(name, \"yellow\") ~ \"YELLOW\",\n                                           str_detect(name, \"blue\") ~ \"BLUE\",\n                                           .default = \"other\"))\n\ncrayons_groups %>% head(5)\n```\n\n\n### Fuzzy join\n\nThe approach above works well for a small number of groups but it can become cumbersome when you have lots of groups to assign. If we wanted to sort the crayons into many more color groups, a better approach would be to create a table to store our group names and the color word associated with it. Then we can use `fuzzyjoin` to join the groups table to the crayons table. The end result is the same, but it requires less code and will be much easier to update when we want to add new groups or change the words associated with a group.\n\nHere's the same example as above using the new table approach.\n\n\n### Create the group table\n\nFirst, create a table of our groups with two columns:\n\n- `group` The group name\n- `word` The word associated with the group\n\n```{r}\nlibrary(tidyverse)\nlibrary(fuzzyjoin)\n\ncolor_groups <- tibble(group = c('RED','YELLOW','BLUE'), \n                       word = c(\"red\", \"yellow\", \"blue\")) \n```\n\n\n### Join groups with fuzzy_left_join\n\nNow we can join our two tables using the `name` column in the *crayons* table, and the `word` column in the *color_groups* table. The function used to match the crayon name to its group is `str_detect`, which tests whether a given word occurs anywhere in the crayon's name. \n\n```{r}\ncrayons_groups <- crayons %>%\n                  fuzzy_left_join(color_groups, \n                                  by = join_by(name == word), \n                                  match_fun = str_detect)\n\ncrayons_groups %>% head()\n```\n\n\n### Set the `NA`'s group to \"other\"\n\nFinally, we'll use `replace_na()` to assign all of the crayons without a color group to the group \"other\".\n\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  replace_na(list(group = \"other\"))\n\ncrayons_groups %>%\n  select(id, name, group) %>%\n  head(10)\n```\n\n\n> Now that's interesting. Why do you think the **incredible pink** crayon was assigned to the group `RED`?\n\n\n### Finding complete words\n\nIn the example above, the function `str_detect()` looked for the occurrence of the designated letters anywhere in the crayon name. So the pattern of letters \"r-e-d\" is detected even if it occurs within another word. In this case, the pattern occurs within the name \"inc**red**ible pink\". That could be useful in some contexts, but in our current crayon situation, we only want to detect the word \"red\". \n\nTo ensure the color \"red\" is only detected as a complete word, we can add a special character to the start and end of our search term. Adding the character `\\\\b` to both sides of \"red\" will require the letters \"r-e-d\" to occur as its own word and not as part of a longer word.\n\nFinally, let's paste `\\\\b` to both sides of the color words in the *color_groups* table and then try our fuzzyjoin one more time.\n\n```{r}\ncolor_groups <- color_groups %>%\n                mutate(word = paste0(\"\\\\b\", word, \"\\\\b\"))\n\n# Join the groups again, but with the added separate word requirement\ncrayons_groups <- crayons %>%\n                  fuzzy_left_join(color_groups, \n                                  by = join_by(name == word), \n                                  match_fun = str_detect)\n\ncrayons_groups %>%\n  select(id, name, group) %>%\n  head(10)\n```\n\n\n> Success!\n\n\n### The **\"other\"** group\n\nWe can lump the remaining crayons that were not labeled with a primary color into an *other* group. The `replace_na()` function is used to replace all of the `NA` values in a given column. Let's use it to set the group for the `NA` crayons to \"other\".\n\n\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  replace_na(list(group = \"other\"))\n\ncrayons_groups %>%\n  select(id, name, group) %>%\n  head(10)\n```\n\n## Assign umbrella groups: Parent and child nodes\n\nWe want to sort our crayons into primary colors and secondary colors. To do this we'll need to check a crayon name for multiple words. For example, a crayon will be assigned to the primary color group if any of the following words occur in its name: `red`, `yellow`, or `blue`.\n\nThe larger umbrella group is sometimes referred to as the *parent node*, and the individual terms that fall under it are its *children nodes*. Here's the table of our color groups in terms of parent and child nodes.\n\n```{r}\ncolor_group_nodes <- tribble(\n  ~parent, ~child,\n  \"primary\",   \"red\",\n  \"primary\",   \"yellow\",\n  \"primary\",   \"blue\",\n  \"secondary\", \"green\",\n  \"secondary\", \"orange\",\n  \"secondary\", \"purple\",\n)\n```\n\n\n## Fuzzy join primary and secondary\n\nNow we can repeat our previous fuzzy join steps to assign each of the crayons to `primary`, `secondary`, or `other`.\n\n```{r}\ncolor_group_nodes <- color_group_nodes %>%\n                     mutate(child_word = paste0(\"\\\\b\", child, \"\\\\b\"))\n\n# Join the primary/secondary groups\ncrayons_groups <- crayons %>%\n                  fuzzy_left_join(color_group_nodes, \n                                  by = join_by(name == child_word), \n                                  match_fun = str_detect) %>%\n                  replace_na(list(parent = \"other\"))\n\ncrayons_groups %>%\n  select(id, name, parent, child) %>%\n  head(10)\n```\n\n\n\n## Assign multiple tags\n\nWhen we work with longer pieces of text we may want to assign it multiple groups or tags. For example, the description of a kids' TV show may be about both `dinosaurs` and `siblings`. \n\nIn this example we will label the shows about people and tag each description with the type of people it references, such as `sister`, `brother`, or `grandmother`.\n\n### Load kids TV data\n```{r}\n#| echo: false\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(fuzzyjoin)\n```\n\n```{r}\n#| cache: true\n\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(fuzzyjoin)\n\ntv_shows <- read_csv('https://tidy-mn.github.io/qualitative-guide/posts/data/kids_netflix_shows.csv')\n```\n\n\n### Split up / `unnest` every word for easy group joining\n```{r}\ntv_shows <- tv_shows %>%\n            unnest_tokens(word, description, drop = FALSE)\n```\n\n\n### Load the parent and child node table\n\nHere we provide an example parent/child node table to tag descriptions with various types of people. We include both the singular and plural version of a term - such as *uncle* and *uncles*. \n\n```{r}\ntv_nodes <- read_csv(\"https://tidy-mn.github.io/qualitative-guide/posts/data/people_nodes.csv\")\n\ntv_nodes %>% head()\n```\n\n\n\n### Join the parent/child `nodes` table to the `tv_shows`\n\n```{r}\ntv_groups <- tv_shows %>%\n             left_join(tv_nodes, \n                       by = join_by(word == child_words))\n\n# Drop the rows/words with no word matches\ntv_groups <- tv_groups %>%\n             filter(!is.na(parent))\n\n# View word matches\ntv_groups %>%\n  select(title, description, parent, child) %>%\n  arrange(child) %>%\n  head() %>%\n  knitr::kable()\n```\n\n\n## Summarize\n\nTo simplify things, let's take all of the assigned parent and child tags for each movie and bring them together into a comma separated list.\n```{r}\ntv_groups <- tv_groups %>%\n              filter(!is.na(parent)) %>%\n              group_by(show_id, type, title, country, release_year, description) %>%\n              summarize(parent_nodes = paste(parent %>% unique %>% sort, collapse = \", \"),\n                        child_nodes = paste(child %>% unique %>% sort, collapse = \", \"),\n                        .groups = \"drop\")\n  \n# View r\ntv_groups %>%\n  select(title, description, parent_nodes, child_nodes) %>%\n  arrange(-nchar(child_nodes)) %>%\n  head(12) %>%\n  knitr::kable()\n```  \n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"toc-depth":3,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","theme":"minty","title-block-banner":false,"title":"3 — Group and code responses","date":"2024-01-03","date-modified":"last-modified","image":"sort_elmo.png","categories":["code","group","themes"],"message":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
{"title":"3 — Group and code responses","markdown":{"yaml":{"title":"3 — Group and code responses","date":"2024-01-03","date-modified":"last-modified","image":"sort_elmo.png","format":{"html":{"toc":true,"toc-depth":3,"warning":false,"message":false}},"categories":["code","group","themes"]},"headingText":"Crayon colors","containsRefs":false,"markdown":"\n\n\n\n<img src=\"crayons.jpg\" style=\"margin-right: 16px; margin-bottom: 2px; margin-left: -20px;\" align=\"left\" width=\"184\" alt=\"A box of 12 Crayola crayons.\">\n\nLet's start simple and assign crayons a color based on their descriptive names. Below is a table of 12 crayons and their names. We want to create a group for each of the primary colors - `red`, `yellow`, and `blue` - and an everything-else group labeled `other`. \n\nWe'll begin by searching for the primary color words in the name column of each of the crayons. If a color word is *detected*, it will be assigned to the appropriate group. \n\n\n### Load the data\n```{r}\nlibrary(tidyverse)\nlibrary(tidytext)\n\n\ncrayons <- read_csv('https://tidy-mn.github.io/qualitative-guide/posts/data/crayons.csv') \n\ncrayons\n```\n\n\n### Find color words\n\nWe'll use `case_when()` and `str_detect()` to test if a crayon name contains a given primary color word. If it does, we'll assign the crayon to that color. If none of the primary color words are detected, the crayon will be assigned to the group `other`.\n\n```{r}\ncrayons_groups <- crayons %>%\n                  mutate(group = case_when(str_detect(name, \"red\") ~ \"RED\",\n                                           str_detect(name, \"yellow\") ~ \"YELLOW\",\n                                           str_detect(name, \"blue\") ~ \"BLUE\",\n                                           .default = \"other\"))\n\ncrayons_groups %>% head(5)\n```\n\n\n### Joining groups and codes\n\nThe approach above works well for a small number of groups, but it can be cumbersome when you have lots of groups to assign. If we wanted to sort the crayons into many more color groups, a better approach would be to create a table to store our group names and the associated color word. \n\nThen we can join the groups table to the crayons table. The end result is the same, but it requires less code and will be much easier to update when we want to add new groups or change the words associated with a group.\n\nHere's the same example as above using the table joining approach.\n\n\n### Create the group table\n\nFirst, create a table of our groups with two columns:\n\n- `color_group` The group's name\n- `word` The word associated with the group\n\n```{r}\n\ncolor_groups <- tibble(color_group = c('RED','YELLOW','BLUE'), \n                       word = c(\"red\", \"yellow\", \"blue\")) \n```\n\n\n\n### Split-up (`unnest`) the words in the crayon names for easy joining\n```{r}\ncrayons <- crayons %>%\n           unnest_tokens(word, name, drop = FALSE)\n```\n\n\n### Join groups with `left_join`\n\nNow we can join our two tables using the `word` column in the *crayons* table, and the `word` column in the *color_groups* table. The function used to join the tables together is `left_join`. It has a `by` argument used to set the columns for linking the two tables together. In this case, the tables both share a column named `word` that we want to join by.\n\n```{r}\ncrayons_groups <- crayons %>%\n                  left_join(color_groups, \n                           by = join_by(word == word))\n\ncrayons_groups %>% head()\n```\n\n\n### Summarize\n\nTo reduce this long list of words down to a single row for each crayon, we can use the function `fill()` and `slice_head()`.\n\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  group_by(id, name) %>%\n                  fill(color_group, .direction = \"updown\") %>%\n                  slice_head(n = 1) %>%\n                  select(-word)\n\ncrayons_groups %>% head()\n```\n\n\n### Set `NA`'s group to \"other\"\n\nFinally, to tidy things up we'll use `replace_na()` to assign the crayons without a color group to a group called \"other\".\n\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  replace_na(list(color_group = \"other\"))\n\ncrayons_groups %>% head(10)\n```\n\n\n> **Success!**\n\n\n\n## Using umbrella groups: Parent and child codes\n\nWe want to sort our crayons into primary colors and secondary colors. To do this we'll need to check a crayon name for multiple words. For example, a crayon will be assigned to the primary color group if any of the following words occur in its name: `red`, `yellow`, or `blue`.\n\nThe larger umbrella group is sometimes referred to as the *parent code*, and the individual terms that fall under it are its *children codes*. Here's the table of our color groups in terms of parent and child codes.\n\n```{r}\ncolor_group_codes <- tribble(\n  ~parent, ~child,\n  \"primary\",   \"red\",\n  \"primary\",   \"yellow\",\n  \"primary\",   \"blue\",\n  \"secondary\", \"green\",\n  \"secondary\", \"orange\",\n  \"secondary\", \"purple\",\n)\n```\n\n\n### Join primary and secondary\n\nNow we can repeat our previous fuzzy join steps to assign each of the crayons to the groups: `primary`, `secondary`, or `other`.\n\n```{r}\ncrayons_groups <- crayons %>%\n                  left_join(color_group_codes, \n                            by = join_by(word == child)) \n\ncrayons_groups %>% head(10)\n```\n\n\n#### Tidy up\n\nRepeat our clean-up steps with `group_by`, `fill`, `slice_head`, and `replace_na`.\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  group_by(id, name) %>%\n                  fill(parent, .direction = \"updown\") %>%\n                  slice_head(n = 1) %>%\n                  select(-word) %>%\n                  replace_na(list(parent = \"other\"))\n\ncrayons_groups %>% head(10)\n```\n\n\n\n\n## Assign multiple tags or codes\n\nWhen we work with longer pieces of text we may want to assign a piece of text to multiple groups or tags. For example, the description of a kids' TV show may be about both `dinosaurs` and `sisters`. \n\nIn this example, we will label the shows about people and tag each description with the types of people it references, such as `sister`, `brother`, or `grandmother`.\n\n### Load kids TV data\n```{r}\n#| echo: false\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(fuzzyjoin)\n```\n\n```{r}\n#| cache: true\n\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(fuzzyjoin)\n\ntv_shows <- read_csv('https://tidy-mn.github.io/qualitative-guide/posts/data/kids_netflix_shows.csv')\n```\n\n\n### Split-up (`unnest`) the words for easy joining\n```{r}\ntv_shows <- tv_shows %>%\n            unnest_tokens(word, description, drop = FALSE)\n```\n\n\n### Load the parent and child code table\n\nHere we provide an example parent/child code table to tag descriptions with various types of people. Both the singular and plural version of each term is included - such as *uncle* and *uncles*. \n\n```{r}\npeople_codes <- read_csv(\"https://tidy-mn.github.io/qualitative-guide/posts/data/people_codes.csv\")\n\npeople_codes %>% head()\n```\n\n\n\n### Join the `parent_codes` table to the `tv_shows`\n\n```{r}\ntv_groups <- tv_shows %>%\n             left_join(people_codes, \n                       by = join_by(word == child_words))\n\n# Drop the rows/words with no word matches\ntv_groups <- tv_groups %>%\n             filter(!is.na(parent))\n\n# View word matches\ntv_groups %>%\n  select(title, description, parent, child) %>%\n  arrange(child) %>%\n  head() %>%\n  knitr::kable()\n```\n\n\n## Summarize\n\nTo simplify things, let's take all of the parent and child tags assigned to each movie and bring them together into a comma separated list.\n\n```{r}\ntv_groups <- tv_groups %>%\n              filter(!is.na(parent)) %>%\n              group_by(show_id, type, title, country, release_year, description) %>%\n              summarize(parent_codes = paste(parent %>% unique %>% sort, collapse = \", \"),\n                        child_codes = paste(child %>% unique %>% sort, collapse = \", \"),\n                        .groups = \"drop\")\n  \n# View assigned codes in a single list\ntv_groups %>%\n  select(title, description, parent_codes, child_codes) %>%\n  arrange(-nchar(child_codes)) %>%\n  head() %>%\n  knitr::kable()\n```  \n\n","srcMarkdownNoYaml":"\n\n\n## Crayon colors\n\n<img src=\"crayons.jpg\" style=\"margin-right: 16px; margin-bottom: 2px; margin-left: -20px;\" align=\"left\" width=\"184\" alt=\"A box of 12 Crayola crayons.\">\n\nLet's start simple and assign crayons a color based on their descriptive names. Below is a table of 12 crayons and their names. We want to create a group for each of the primary colors - `red`, `yellow`, and `blue` - and an everything-else group labeled `other`. \n\nWe'll begin by searching for the primary color words in the name column of each of the crayons. If a color word is *detected*, it will be assigned to the appropriate group. \n\n\n### Load the data\n```{r}\nlibrary(tidyverse)\nlibrary(tidytext)\n\n\ncrayons <- read_csv('https://tidy-mn.github.io/qualitative-guide/posts/data/crayons.csv') \n\ncrayons\n```\n\n\n### Find color words\n\nWe'll use `case_when()` and `str_detect()` to test if a crayon name contains a given primary color word. If it does, we'll assign the crayon to that color. If none of the primary color words are detected, the crayon will be assigned to the group `other`.\n\n```{r}\ncrayons_groups <- crayons %>%\n                  mutate(group = case_when(str_detect(name, \"red\") ~ \"RED\",\n                                           str_detect(name, \"yellow\") ~ \"YELLOW\",\n                                           str_detect(name, \"blue\") ~ \"BLUE\",\n                                           .default = \"other\"))\n\ncrayons_groups %>% head(5)\n```\n\n\n### Joining groups and codes\n\nThe approach above works well for a small number of groups, but it can be cumbersome when you have lots of groups to assign. If we wanted to sort the crayons into many more color groups, a better approach would be to create a table to store our group names and the associated color word. \n\nThen we can join the groups table to the crayons table. The end result is the same, but it requires less code and will be much easier to update when we want to add new groups or change the words associated with a group.\n\nHere's the same example as above using the table joining approach.\n\n\n### Create the group table\n\nFirst, create a table of our groups with two columns:\n\n- `color_group` The group's name\n- `word` The word associated with the group\n\n```{r}\n\ncolor_groups <- tibble(color_group = c('RED','YELLOW','BLUE'), \n                       word = c(\"red\", \"yellow\", \"blue\")) \n```\n\n\n\n### Split-up (`unnest`) the words in the crayon names for easy joining\n```{r}\ncrayons <- crayons %>%\n           unnest_tokens(word, name, drop = FALSE)\n```\n\n\n### Join groups with `left_join`\n\nNow we can join our two tables using the `word` column in the *crayons* table, and the `word` column in the *color_groups* table. The function used to join the tables together is `left_join`. It has a `by` argument used to set the columns for linking the two tables together. In this case, the tables both share a column named `word` that we want to join by.\n\n```{r}\ncrayons_groups <- crayons %>%\n                  left_join(color_groups, \n                           by = join_by(word == word))\n\ncrayons_groups %>% head()\n```\n\n\n### Summarize\n\nTo reduce this long list of words down to a single row for each crayon, we can use the function `fill()` and `slice_head()`.\n\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  group_by(id, name) %>%\n                  fill(color_group, .direction = \"updown\") %>%\n                  slice_head(n = 1) %>%\n                  select(-word)\n\ncrayons_groups %>% head()\n```\n\n\n### Set `NA`'s group to \"other\"\n\nFinally, to tidy things up we'll use `replace_na()` to assign the crayons without a color group to a group called \"other\".\n\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  replace_na(list(color_group = \"other\"))\n\ncrayons_groups %>% head(10)\n```\n\n\n> **Success!**\n\n\n\n## Using umbrella groups: Parent and child codes\n\nWe want to sort our crayons into primary colors and secondary colors. To do this we'll need to check a crayon name for multiple words. For example, a crayon will be assigned to the primary color group if any of the following words occur in its name: `red`, `yellow`, or `blue`.\n\nThe larger umbrella group is sometimes referred to as the *parent code*, and the individual terms that fall under it are its *children codes*. Here's the table of our color groups in terms of parent and child codes.\n\n```{r}\ncolor_group_codes <- tribble(\n  ~parent, ~child,\n  \"primary\",   \"red\",\n  \"primary\",   \"yellow\",\n  \"primary\",   \"blue\",\n  \"secondary\", \"green\",\n  \"secondary\", \"orange\",\n  \"secondary\", \"purple\",\n)\n```\n\n\n### Join primary and secondary\n\nNow we can repeat our previous fuzzy join steps to assign each of the crayons to the groups: `primary`, `secondary`, or `other`.\n\n```{r}\ncrayons_groups <- crayons %>%\n                  left_join(color_group_codes, \n                            by = join_by(word == child)) \n\ncrayons_groups %>% head(10)\n```\n\n\n#### Tidy up\n\nRepeat our clean-up steps with `group_by`, `fill`, `slice_head`, and `replace_na`.\n```{r}\ncrayons_groups <- crayons_groups %>%\n                  group_by(id, name) %>%\n                  fill(parent, .direction = \"updown\") %>%\n                  slice_head(n = 1) %>%\n                  select(-word) %>%\n                  replace_na(list(parent = \"other\"))\n\ncrayons_groups %>% head(10)\n```\n\n\n\n\n## Assign multiple tags or codes\n\nWhen we work with longer pieces of text we may want to assign a piece of text to multiple groups or tags. For example, the description of a kids' TV show may be about both `dinosaurs` and `sisters`. \n\nIn this example, we will label the shows about people and tag each description with the types of people it references, such as `sister`, `brother`, or `grandmother`.\n\n### Load kids TV data\n```{r}\n#| echo: false\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(fuzzyjoin)\n```\n\n```{r}\n#| cache: true\n\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(fuzzyjoin)\n\ntv_shows <- read_csv('https://tidy-mn.github.io/qualitative-guide/posts/data/kids_netflix_shows.csv')\n```\n\n\n### Split-up (`unnest`) the words for easy joining\n```{r}\ntv_shows <- tv_shows %>%\n            unnest_tokens(word, description, drop = FALSE)\n```\n\n\n### Load the parent and child code table\n\nHere we provide an example parent/child code table to tag descriptions with various types of people. Both the singular and plural version of each term is included - such as *uncle* and *uncles*. \n\n```{r}\npeople_codes <- read_csv(\"https://tidy-mn.github.io/qualitative-guide/posts/data/people_codes.csv\")\n\npeople_codes %>% head()\n```\n\n\n\n### Join the `parent_codes` table to the `tv_shows`\n\n```{r}\ntv_groups <- tv_shows %>%\n             left_join(people_codes, \n                       by = join_by(word == child_words))\n\n# Drop the rows/words with no word matches\ntv_groups <- tv_groups %>%\n             filter(!is.na(parent))\n\n# View word matches\ntv_groups %>%\n  select(title, description, parent, child) %>%\n  arrange(child) %>%\n  head() %>%\n  knitr::kable()\n```\n\n\n## Summarize\n\nTo simplify things, let's take all of the parent and child tags assigned to each movie and bring them together into a comma separated list.\n\n```{r}\ntv_groups <- tv_groups %>%\n              filter(!is.na(parent)) %>%\n              group_by(show_id, type, title, country, release_year, description) %>%\n              summarize(parent_codes = paste(parent %>% unique %>% sort, collapse = \", \"),\n                        child_codes = paste(child %>% unique %>% sort, collapse = \", \"),\n                        .groups = \"drop\")\n  \n# View assigned codes in a single list\ntv_groups %>%\n  select(title, description, parent_codes, child_codes) %>%\n  arrange(-nchar(child_codes)) %>%\n  head() %>%\n  knitr::kable()\n```  \n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"toc-depth":3,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","theme":"minty","title-block-banner":false,"title":"3 — Group and code responses","date":"2024-01-03","date-modified":"last-modified","image":"sort_elmo.png","categories":["code","group","themes"],"message":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}